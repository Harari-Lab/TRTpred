suppressMessages(require(Seurat))
suppressMessages(require(foreach))
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(tidyverse))

DEFAULT.LR.HYPERPARAMS <- list("alpha" = 0, "lambda" = 0)
DEFAULT.SIGNATURE.HYPERPARAMS <- list("signature.lengths" = c(20), 
                                      "signature.side" = c("both"),
                                      "signature.rm.regex" = "none",
                                      "signature.methods" = c("AUCell"),
                                      "signature.selection.method" = c("logFC"))
DA.METHODS <- c("wilcox")
P.ADJUST.METHODS <- c("fdr", "bonferroni", "holm", "hochberg", "hommel", "BH", "BY", "none")
LIMMA.METHODS <- c("limma_voom", "limma_trend")
EDGER.METHODS <- c("edgeR_LRT", "edgeR_QFL")
DESEQ.METHODS <- c("DESeq2_Wald", "DESeq2_LRT")
SEURAT.METHODS <- c("wilcox", "bimod", "roc", "t", "negbinom", "poisson", "LR")
DEA.METHODS <- c(SEURAT.METHODS, DESEQ.METHODS, LIMMA.METHODS, EDGER.METHODS)
FEATURE.TRANS.METHODS <- c("pca", "opls")
EVALUATION.METRICS <- c("mcc", "accuracy", "F1", "kappa", "auc", "sensitivity", "specificity", "PPV", "NPV")



#' Get Models perdiction
#' 
#' Home function to train and test a model (LR or signature )
#' 
#' @param data.input data.frame or matrix; The input matrix corresponding to the feature 
#' space only. Additional covariates are found in `y`. Rows = samples, Columns = features
#' @param data.output data.frame or matrix; The output matrix. 
#' Columns = c(y.label, y.covariates, y.sample)
#' @param y.label character; The column of `y` corresponding to the binary output
#' @param path.folder character; Folder to retieve the model / data / info
#'  @param method character; The prediction method. Possible values are: "LR": 
#' Logistic regression or "signature" signature-score approach. 
#' @param hyperparams list: The hyper-parameter list. 
#' if method = "LR": Elements of list are 
#'   - "alpha" (L2-regularization): Vector of alpha values (0-1)
#'   - "lambda" (L1-regularization): Vector of lambda values (0-1)
#' if method = "signature": Elements of list are 
#'   - "signature.lengths": Vector of signature lengths
#'   - "signature.side": Vector of siganture sides ("up", "down" or "both")
#'   - "signature.rm.regex": Vector of rm.regex (regex to remove genes from signature)
#'   - "signature.methods": Vector of signature score methods
#'   - "signature.selection.method": How to select genes from DEA res using the log-Fold-Change ("logFC") or p-values ("pval")
#' @param data.trans.method character: The data transforamtion method. 
#' Possible values are "pca" 
#' Default = "none" i.e. no transformation. 
#' @param DEA.file.name character; The name of the DEA file 
#' Default = "dea.res.rds"
#' @param signature.x.threshold numerical; The signature score threhsold
#' Default = 0
#' @param LR.model.file.name character; The name of the LR file. 
#' If NULL, generate the file name generated by LRCrossValidation()
#' Default = NULL
#' @param LR.prob.threhsold numeric; The probability threshold for the logitic regression
#' Default = 0.5
#' 
#' @return data.frame; Rows = barcode names in x. Cols = "score" and "pred"
#' 
#' @export
GetModelPrediction <- function(data.input, data.output, y.label, 
                               path.folder, 
                               method, hyperparameters,
                               data.trans.method, 
                               DEA.file.name = "dea.res.rds", signature.x.threshold = 0,
                               signature.score.scale = T, signature.score.scale.params = NULL,
                               LR.model.file.name = NULL, LR.prob.threhsold = NULL){
  
  PrepareData.list <- PrepareData(
    x.train = data.input, 
    y.train = data.output, 
    y.label = y.label, 
    method = method,
    data.trans.method = data.trans.method, 
    rm.corr.features = F, 
    DA.method = "none")
  
  if (method == "signature") {
    prediction.res <- GetPredictionSignature(
      x = PrepareData.list$data.train, 
      path.folder = path.folder, 
      DEA.file.name = DEA.file.name, 
      hyperparameters = hyperparameters, 
      score.threshold = signature.x.threshold, 
      score.to.scale = signature.score.scale, 
      score.scale.params = signature.score.scale.params)
    
  } else if (method == "LR") {
    prediction.res <- GetLRPrediction(
      x = PrepareData.list$data.train, 
      path.folder = path.folder, 
      model.file.name = LR.model.file.name, 
      prob.threshold = LR.prob.threhsold,
      hyperparameters = hyperparameters)
  }
  
  return(prediction.res)
}


#' Train Model function
#' 
#' Home function to train and test a model (LR or signature )
#' 
#' @param x.train data.frame or matrix; The input matrix corresponding to the feature 
#' space only. Additional covariates are found in `y`. Rows = samples, Columns = features
#' @param y.train data.frame or matrix; The output matrix. 
#' Columns = c(y.label, y.covariates, y.sample)
#' @param x.test data.frame or matrix; The input data like x.train but for testing
#' @param y.test data.frame or matrix; The output matrix like y.train but for testing
#' @param y.label character; The column of `y` corresponding to the binary output
#' @param y.covariates character vector; The columns of `y` corresponding to the covariates
#' @param y.sample character; The column of `y` corresponding to the samples for when method = "signature"
#' @param method character; The prediction method. Possible values are: "LR": 
#' Logistic regression or "signature" signature-score approach. 
#' @param hyperparams list: The hyper-parameter list. 
#' if method = "LR": Elements of list are 
#'   - "alpha" (L2-regularization): Vector of alpha values (0-1)
#'   - "lambda" (L1-regularization): Vector of lambda values (0-1)
#' if method = "signature": Elements of list are 
#'   - "signature.lengths": Vector of signature lengths
#'   - "signature.side": Vector of siganture sides ("up", "down" or "both")
#'   - "signature.rm.regex": Vector of rm.regex (regex to remove genes from signature)
#'   - "signature.methods": Vector of signature score methods
#'   - "signature.selection.method": How to select genes from DEA res using the log-Fold-Change ("logFC") or p-values ("pval")
#' @param data.trans.method character: The data transforamtion method. 
#' Possible values are "pca" 
#' Default = "none" i.e. no transformation. 
#' @param pca.explained.var.threshold numeric: If not NULL, apply this threshold 
#' to select PCs explaining more variance than the threhsold
#' @param rm.corr.features logical: Do we remove the mutually correlated feature 
#' while keeping the ones that best correlate with the outcome? 
#' default = F
#' @param DA.method character; The discriminant analysis (DA) method. 
#' Possible values are "wilcox"
#' Default = "none" i.e. no discriminant analysis
#' @param DA.p.adjust.method character; The p-value adjust method for the 
#' discriminant analysis. 
#' Default = "fdr"
#' @param DA.p.val.threshold numeric; The p-val significant threshold. 
#' @param DA.event.per.variable, numerical; The number of event per variable threshold
#' A common EPV is 10 meaning that we need 10 event per variable. Here we use it as 
#' a way to select a fewer amount of variables for a fixed amount of samples. 
#' Default = NULL (no selection on EPV)
#' @param LR.prob.threhsold numeric; The probability threshold for the logitic regression
#' @param signature.col.aggregate character; Column in data.train@meta.data to combine cells into pseudobulk. 
#' If NULL, no pseudobulk integration
#' Default = NULL
#' @param DEA.method character; The Differential-expression-analylsis method (see RunDEA())
#' default = "wilcox" from the Seurat::FindMarker() function
#' @param DEA.data data.frame or matrix; The input matrix for the DEA. 
#' Rows = samples, Columns = features. If NULL, the DEA.data is x
#' Default = NULL
#' @param sample.weights data.frame (rows = observation, column = weight); The 
#' observation weights data.frame. 
#' Default = NULL i.e. 1 for each observation
#' @param folds.save.folder character; Folder to save the model information. 
#' If null doesn't save anything. 
#' default = NULL
#' 
#' @return data.frame summarizing the Nested-cross-validation
#' 
#' @export
TrainModel <- function(x.train, y.train, 
                       y.label, y.covariates = NULL, y.sample = NULL,
                       x.test = NULL, y.test = NULL,
                       method = c("LR", "signature"),
                       hyperparams = NULL,
                       data.trans.method = c("none", FEATURE.TRANS.METHODS), 
                       pca.explained.var.threshold = NULL,
                       rm.corr.features = F,
                       DA.method = c("none", DA.METHODS),
                       DA.p.adjust.method = P.ADJUST.METHODS,
                       DA.p.val.threshold = 0.05,
                       DA.event.per.variable = NULL,
                       LR.prob.threhsold = NULL,
                       signature.col.aggregate = NULL,
                       DEA.method = DEA.METHODS, 
                       DEA.data = NULL,
                       sample.weights = NULL,
                       folds.save.folder = NULL,
                       save.fold.model = F, 
                       save.fold.pred = F, 
                       save.fold.score = F){
  
  # Setting parameters: 
  method <- match.arg(method) # default = "LR"
  data.trans.method <- match.arg(data.trans.method) # default = "none"
  DA.method <- match.arg(DA.method) # default = "none"
  DA.p.adjust.method <- match.arg(DA.p.adjust.method) # default = "fdr"
  DEA.method <- match.arg(DEA.method) # default = "wilcox"
  
  if (!is.null(x.test)){
    if (nrow(x.test) == 0){
      x.test <- NULL
      y.test <- NULL
    }
  }
  
  data.input.list <- PrepareData(
    x.train = x.train,
    y.train = y.train,
    y.label = y.label,
    x.test = x.test,
    y.test = y.test,
    DEA.data = DEA.data,
    method = method,
    data.trans.method = data.trans.method,
    pca.explained.var.threshold = pca.explained.var.threshold,
    rm.corr.features = rm.corr.features,
    rm.corr.features.threhsold = 0.8,
    DA.method = DA.method,
    DA.p.adjust.method = DA.p.adjust.method,
    DA.p.val.threshold = DA.p.val.threshold,
    DA.event.per.variable = DA.event.per.variable)
  
  
  if (method == "LR"){
    
    # Define the design of the model
    col.features <- colnames(data.input.list$data.train)
    col.features <- col.features[!(col.features %in% colnames(y.train))]
    design.str <- paste(y.label, "~", paste(c(col.features, y.covariates), collapse = " + "), sep = " ")
    
    # Run the training
    res.model <- LRCrossValidation(
      data.train = data.input.list$data.train, 
      data.test = data.input.list$data.test,
      design.str = design.str, 
      hyperparams = hyperparams, 
      model.prob.threshold = LR.prob.threhsold,
      sample.weights = sample.weights,
      folds.save.folder = folds.save.folder,
      save.model = save.fold.model, 
      save.pred = save.fold.pred, 
      save.score = save.fold.score
      )
    
  } else if (method == "signature"){
    # Get the results of the model for all hyperparmeters
    res.model <- SignatureCrossValidation(
      data.train = data.input.list$data.train, 
      data.test = data.input.list$data.test, 
      DEA.data = data.input.list$DEA.data,
      y.label = y.label, 
      y.sample = y.sample, 
      y.covariates = y.covariates, 
      DEA.method = DEA.method,
      signature.selection.method = hyperparams$signature.selection.method,
      signature.lengths = hyperparams$signature.lengths, 
      signature.sides = hyperparams$signature.side, 
      signature.rm.regex = hyperparams$signature.rm.regex, 
      signature.methods = hyperparams$signature.methods, 
      assay = "RNA", # in data.train assay "RNA" contains now the correct set of data
      slot = "data", # in data.train slot "data" contains now the correct set of data
      col.aggregate = signature.col.aggregate,
      sample.weights = sample.weights,
      folds.save.folder = folds.save.folder,
      save.model = save.fold.model, 
      save.pred = save.fold.pred, 
      save.score = save.fold.score)
  }
  
  res.model[["n.data.input"]] <- nrow(x.train)
  res.model[["p.data.input"]] <- ncol(x.train)
  
  return(res.model)
}
